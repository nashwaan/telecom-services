// silence JSLint error: variable used before it was defined
/*global module*/
/*global require*/

// wrapper function (required by grunt and its plugins)
module.exports = function (grunt) {
    'use strict';

    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json') // get the configuration info from package.json like name and version (pkg.name)
    });

    // configure jshint to validate js files  
    grunt.loadNpmTasks('grunt-contrib-jshint');
    grunt.config('jshint', {
        options: {
            banner: '/*\n <%= pkg.name %> <%= grunt.template.today("yyyy-mm-dd") %> \n*/\n',
            reporter: require('jshint-stylish') // use jshint-stylish to make our errors look and read good
        },
        prod: {
            src: ['Gruntfile.js', '**/*.js']
        }
    });

    // configure uglify to minify js files 
    grunt.loadNpmTasks('grunt-contrib-uglify');
    grunt.config('uglify', {
        options: {
            banner: '/*\n <%= pkg.name %> <%= grunt.template.today("yyyy-mm-dd") %> \n*/\n'
        },
        prod: {
            nonull: true,
            src: ['app/*.js', 'app/*-part/*.js'],
            dest: 'app/app.min.js'
        }
    });

    // configure cssmin to minify css files ------------------------------------
    grunt.loadNpmTasks('grunt-contrib-cssmin');
    grunt.config('cssmin', {
        options: {
            banner: '/*\n <%= pkg.name %> <%= grunt.template.today("yyyy-mm-dd") %> \n*/\n'
        },
        prod: {
            nonull: true,
            src: ['app/*.css', 'app/*-part/*.css'],
            dest: 'app/app.min.css'
        }
    });

    grunt.registerMultiTask('combineIcons', 'Enclose <svg> tag to each of the svg files generated by svgcombine.', function () {
        var done = this.async(),
            xml2js = require('xml2js'),
            xmlParser = new xml2js.Parser(),
            xmlBuilder = new xml2js.Builder(),
            path = require('path'),
            pd = require('pretty-data').pd,
            SVGO = require('svgo'),
            svgo = new SVGO({
                plugins: [{
                    sortAttrs: true
                }, {
                    removeTitle: true
                }, {
                    removeDimensions: true
                }]
            });

        this.files.forEach(function (file) {
            var contents = file.src.filter(function (filepath) {
                if (!grunt.file.exists(filepath)) { // Remove nonexistent files (it's up to you to filter or warn here).
                    grunt.log.warn('Source file "' + filepath + '" not found.');
                    return false;
                } else {
                    return true;
                }
            }).map(function (filepath) {
                var srcSvg = grunt.file.read(filepath),
                    filename = path.basename(filepath, path.extname(filepath)),
                    optimizedSvg;
                svgo.optimize(srcSvg, function (result) {
                    optimizedSvg = result.data;
                    xmlParser.parseString(optimizedSvg, function (err, result) {
                        var i,
                            aryStyles,
                            styles = {};
                        if (result.svg.style) {
                            aryStyles = result.svg.style[0]._.replace(/\t/g, "").replace(/\r/g, "").replace(/\n/g, "").slice(0, -1).split("}");
                            delete result.svg.style;
                            for (i = 0; i < aryStyles.length; i += 1) {
                                styles[aryStyles[i].replace(".", "").replace(" ", "").split("{")[0]] = aryStyles[i].split("{")[1];
                            }
                        }
                        delete result.svg.$.width;
                        delete result.svg.$.height;
                        (function iterate(obj) {
                            var key;
                            for (key in obj) {
                                if (obj.hasOwnProperty(key)) {
                                    if (key.indexOf("v:") === 0 || key.indexOf("xmlns") > -1 || key === "id") {
                                        delete obj[key];
                                    } else if (key === "class") {
                                        obj.style = styles[obj[key]];
                                        delete obj[key];
                                    }
                                    if (typeof obj[key] === "object") {
                                        iterate(obj[key]);
                                    }
                                }
                            }
                            if (obj.g && !obj.g.$ && obj.g.length === 1 && obj.g[0].g) {
                                obj.g = obj.g[0].g;
                            }
                        }(result));
                        result.svg.$.id = filename;
                        optimizedSvg = result; //xmlBuilder.buildObject(result);
                    });
                });
                console.log("Parsed " + filepath);
                return optimizedSvg;
            }); //.join('\n');

            contents = {
                svg: {
                    defs: contents
                }
            };
            contents = xmlBuilder.buildObject(contents);
                //grunt.file.write(file.dest, pd.xml('<svg><defs>' + contents + '</defs></svg>')); // write joined contents to destination filepath.
            grunt.file.write(file.dest, pd.xml(contents)); // write joined contents to destination filepath.
            grunt.log.writeln('File "' + file.dest + '" created.'); // print a success message.
        });
        done(true);
    });
    grunt.config('combineIcons', {
        options: {
            banner: '<!--\n <%= pkg.name %> <%= grunt.template.today("yyyy-mm-dd") %> \n-->\n'
        },
        gui: {
            nonull: true,
            src: ['app/icons/gui/*.svg'],
            dest: 'app/icons/gui-icons.svg'
        },
        masters: {
            nonull: true,
            src: ['app/icons/masters/*.svg'],
            dest: 'app/icons/master-icons.svg'
        }
    });

    // this default task will go through all configuration (dev and production) in each task 
    grunt.registerTask('default', ['jshint', 'uglify', 'cssmin', 'icons']);

    // this task will only run the dev configuration 
    //grunt.registerTask('icons', ['svgcombine:master-icons', 'combineIcons']);
    grunt.registerTask('icons', ['combineIcons']);

    // only run production configuration 
    grunt.registerTask('production', ['jshint:production', 'uglify:production', 'cssmin:production', 'less:production']);

    // we can only load these grunt plug-ins if they are in our package.json
    grunt.loadNpmTasks('grunt-contrib-watch');

};